switch(key)
    {
    case GLUT_KEY_UP:
        //basic collision detection
         if(checkPosition('u') == false){
            P->placePlayer(currentPlayerX, currentPlayerY);
         }
         else{
            matrix[currentPlayerX][currentPlayerY] = 1;
            P->movePlayer("up",P->frames);
            matrix[P->getPlayerLoc().x][P->getPlayerLoc().y] = 7;
            cout<< P->getPlayerLoc().x<< "    "<<P->getPlayerLoc().y<<endl;
            showMatrix();
            ///SHORTEST PATH FOR ENEMIES HERE
            //E[0].moveEnemy("up");
            //E[1].moveEnemy("up");
            //E[2].moveEnemy("up");
         }

    break;

    case GLUT_KEY_DOWN:
        if(checkPosition('d') == false){
            P->placePlayer(currentPlayerX, currentPlayerY);
        }
        else{
            matrix[currentPlayerX][currentPlayerY] = 1;
            P->movePlayer("down",P->frames);
            matrix[P->getPlayerLoc().x][P->getPlayerLoc().y] = 7;
            cout<< P->getPlayerLoc().x<< "    "<<P->getPlayerLoc().y<<endl;
            showMatrix();
            ///SHORTEST PATH FOR ENEMIES HERE
            //E[0].moveEnemy("down");
            //E[1].moveEnemy("down");
            //E[2].moveEnemy("down");
        }
    break;

    case GLUT_KEY_LEFT:
        if(checkPosition('l') == false){
            P->placePlayer(currentPlayerX, currentPlayerY);
        }
        else{
            matrix[currentPlayerX][currentPlayerY] = 1;
            P->movePlayer("left",P->frames);
            matrix[P->getPlayerLoc().x][P->getPlayerLoc().y] = 7;
            cout<< P->getPlayerLoc().x<< "    "<<P->getPlayerLoc().y<<endl;
            showMatrix();
            ///SHORTEST PATH FOR ENEMIES HERE
            //E[0].moveEnemy("left");
            //E[1].moveEnemy("left");
            //E[2].moveEnemy("left");
        }
    break;

    case GLUT_KEY_RIGHT:
        if(checkPosition('r') == false){
            P->placePlayer(currentPlayerX, currentPlayerY);
        }
        else{
            matrix[currentPlayerX][currentPlayerY] = 1;
            P->movePlayer("right",P->frames);
            matrix[P->getPlayerLoc().x][P->getPlayerLoc().y] = 7;
            cout<< P->getPlayerLoc().x<< "    "<<P->getPlayerLoc().y<<endl;
            showMatrix();
            ///SHORTEST PATH FOR ENEMIES HERE
            //E[0].moveEnemy("right");
            //E[1].moveEnemy("right");
            //E[2].moveEnemy("right");
        }
    break;

   }


 //switch case for the direction
    switch (direction)
    {
    //moving up
    case 'up':
        currentPlayerX = P->getPlayerLoc().x;
        currentPlayerY = P->getPlayerLoc().y;
        if(matrix[currentPlayerX][currentPlayerY+1] == 0){
            return false;
        }
        else if(matrix[currentPlayerX][currentPlayerY+1] == 5){
            M->loadBackgroundImage(imageVictory);
            activeGame = false;
            readFile();
            return true;
        }
        else{
            return true;
        }
    break;

    //moving down
    case 'down':
        currentPlayerX = P->getPlayerLoc().x;
        currentPlayerY = P->getPlayerLoc().y;
        if(matrix[currentPlayerX][currentPlayerY-1] == 0){
            return false;
        }
        else if(matrix[currentPlayerX][currentPlayerY-1] == 5){
            M->loadBackgroundImage(imageVictory);
            activeGame = false;
            readFile();
            return true;
        }
        else{
            return true;
        }
    break;

    //moving left
    case 'left':
        currentPlayerX = P->getPlayerLoc().x;
        currentPlayerY = P->getPlayerLoc().y;
        if(matrix[currentPlayerX-1][currentPlayerY] == 0){
            return false;
        }
        else if(matrix[currentPlayerX-1][currentPlayerY] == 5){
            M->loadBackgroundImage(imageVictory);
            activeGame = false;
            readFile();
            return true;
        }
        else{
            return true;
        }
    break;

    //moving right
    case 'right':
        currentPlayerX = P->getPlayerLoc().x;
        currentPlayerY = P->getPlayerLoc().y;
        if(matrix[currentPlayerX+1][currentPlayerY] == 0){
            return false;
        }
        else if(matrix[currentPlayerX+1][currentPlayerY] == 5){
            M->loadBackgroundImage(imageVictory);
            activeGame = false;
            readFile();
            return true;
        }
        else{
            return true;
        }
    break;
    }






glColor3f(1.0,1.0,1.0);

    glTranslatef(bundleBrk.x,bundleBrk.y,1.0);
    glRotated(-spin,0,0,1);

    glBindTexture(GL_TEXTURE_2D,bundleTex);
    glScaled(1.0/(float)(gridSize),1.0/(float)(gridSize),1.0);

    glBegin(GL_QUADS);
        glTexCoord2f(0,1);
        glVertex3f(1,-1,0.0f);

       glTexCoord2f(0,0);
        glVertex3f(1,1,0.0f);

        glTexCoord2f(1,0);
        glVertex3f(-1,1,0.0f);

        glTexCoord2f(1,1);
        glVertex3f(-1,-1,0.0f);
     glEnd();

     spin += 0.5;